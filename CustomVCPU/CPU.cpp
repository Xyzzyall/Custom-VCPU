#include "CPU.h"
#include <exception>
#include <string>

#define COPY_REG0_TO_REGX(x) case CMD_COPY_REG0_TO_REGX + x: reg_mem[x] = reg_mem[0]; break;
#define COPY_REGX_TO_REG0(x) case CMD_COPY_REGX_TO_REG0 + x: reg_mem[0] = reg_mem[x]; break;
#define CMD_CMP_REGX(x) case CMD_CMP_REGX + x: compare(reg_mem[0], reg_mem[x]); break;
#define CMD_INC_REGX(x) case CMD_INC_REGX + x: reg_mem[x]++; break;

namespace hardware 
{
	CPU::CPU(int ram_capacity, int prog_mem_capacity)
	{
		//initializing 
		this->ram = new short[ram_capacity];
		this->ram_capacity = ram_capacity;

		this->prog_mem_capacity = prog_mem_capacity;
		this->program = new short[prog_mem_capacity];

		erase_memory();

		reset_regs();
		reset_flags();

		this->current_step = 0;
	}

	CPU::CPU() : CPU(0,0)
	{
	}

	CPU::CPU(const CPU & c) : CPU(c.ram_capacity, c.prog_mem_capacity)
	{
		for (int i; i < ram_capacity; i++)
			ram[i] = c.ram[i];
		for (int i; i < prog_mem_capacity; i++)
			program[i] = c.program[i];

		current_step = c.current_step;

		for (int i; i < CPU_REG_COUNT; i++)
			reg_mem[i] = c.reg_mem[i];

		halt = c.halt;
		sign = c.sign;
		zero = c.zero;

		prog_counter = c.prog_counter;
	}

	void CPU::step()
	{
		if (halt) {
			return;
		}

		//reading current cmd
		unsigned short cmd = read_prog_mem(prog_counter);
		unsigned short op;

		switch (cmd)
		{
		case CMD_CHILL:
			break;
		case CMD_HALT:
			halt = true;
			break;
		case CMD_READ:
			op = read_operand();
			reg_mem[0] = read_ram(op);
			break;
		case CMD_READ_INDEX:
			op = read_operand();
			reg_mem[0] = read_ram(op + reg_mem[CPU_INDEX_REG]);
			break;
		case CMD_CMP_ARRAY:
			compare(reg_mem[CPU_INDEX_REG], reg_mem[CPU_INDEX_REG-1]);
			break;
		case CMD_JUMP:
			op = read_operand();
			prog_counter = op - 1;
			break;
		case CMD_JUMP_SIGN:
			op = read_operand();
			if (sign)
				prog_counter = op - 1;
			break;
		case CMD_JUMP_ZERO:
			op = read_operand();
			if (zero)
				prog_counter = op - 1;
			break;
		case CMD_JUMP_NSIGN:
			op = read_operand();
			if (!sign)
				prog_counter = op - 1;
			break;
		case CMD_JUMP_NZERO:
			op = read_operand();
			if (!zero)
				prog_counter = op - 1;
			break;

			//Macros declarations down there, maybe doing it outside switch was better solution.
			//COPY_REG0_TO_REGX cases generated by macros
			COPY_REG0_TO_REGX(1)
			COPY_REG0_TO_REGX(2)
			COPY_REG0_TO_REGX(3)
			COPY_REG0_TO_REGX(4)
			COPY_REG0_TO_REGX(5)
			COPY_REG0_TO_REGX(6)
			COPY_REG0_TO_REGX(7)

			//COPY_REGX_TO_REG0 cases generated by macros
			COPY_REGX_TO_REG0(1)
			COPY_REGX_TO_REG0(2)
			COPY_REGX_TO_REG0(3)
			COPY_REGX_TO_REG0(4)
			COPY_REGX_TO_REG0(5)
			COPY_REGX_TO_REG0(6)
			COPY_REGX_TO_REG0(7)

			//CMD_CMP_REGX cases generated by macros
			CMD_CMP_REGX(1)
			CMD_CMP_REGX(2)
			CMD_CMP_REGX(3)
			CMD_CMP_REGX(4)
			CMD_CMP_REGX(5)
			CMD_CMP_REGX(6)
			CMD_CMP_REGX(7)

			//CMD_INC_RECX cases generated by macros
			CMD_INC_REGX(0)
			CMD_INC_REGX(1)
			CMD_INC_REGX(2)
			CMD_INC_REGX(3)
			CMD_INC_REGX(4)
			CMD_INC_REGX(5)
			CMD_INC_REGX(6)
			CMD_INC_REGX(7)
		default:
			throw std::exception(("Cannot decode next command. cmd = " + std::to_string(cmd)).c_str());
			break;
		}

		prog_counter++;
		current_step++;
	}

	void CPU::steps(int steps)
	{
		for (int i = 0; i < steps; i++)
		{
			step();
			if (halt) {
				break;
			}
		}
	}

	void CPU::goto_step(int step)
	{
		//WIP feature!!!!
	}

	void CPU::reset_CPU()
	{
		erase_memory();

		reset_regs();
	}

	void CPU::load_memory(std::string prog_bin, std::string ram_bin)
	{
		erase_memory();
		load_program(prog_bin);
		load_ram(ram_bin);
	}

	void CPU::set_memory(short * program, short * ram)
	{
		if ((sizeof(program) / sizeof(short) > prog_mem_capacity) || (sizeof(ram) / sizeof(short) > ram_capacity))
			throw std::exception("Somehow I cannot push this memory to the CPU.");

		for (int i = 0; i < prog_mem_capacity; i++)
		{
			this->program[i] = program[i];
		}

		for (int i = 0; i < ram_capacity; i++)
		{
			this->ram[i] = ram[i];
		}
	}

	void CPU::load_program(std::string bin_file)
	{
		//todo
	}

	void CPU::load_ram(std::string bin_file)
	{
		//todo
	}

	void CPU::erase_memory()
	{
		if ((ram_capacity > 0) && (prog_mem_capacity > 0)) {
			for (int i = 0; i < ram_capacity; i++)
			{
				ram[i] = 0;
			}

			for (int i = 0; i < prog_mem_capacity; i++)
			{
				program[i] = 0;
			}
		}
		else {
			//todo: write nice cool looking exception classes for any type of exceptions
			throw std::exception("Somehow memory size vars is corrupted.");
		}
	}

	std::string CPU::tell_me_about_yourself()
	{
		std::string result = "";
		result += "registers:\n";
		result += "PC = " + std::to_string(prog_counter) + '\n';
		for (int i = 0; i < CPU_REG_COUNT; i++) {
			result += "reg" + std::to_string(i) + " = " + std::to_string(reg_mem[i]) + '\n';
		}
		result += "flags:\n";
		result += "halt = " + std::to_string(halt) + '\n';
		result += "sign = " + std::to_string(sign) + '\n';
		result += "zero = " + std::to_string(zero) + '\n';
		result += "steps done: " + std::to_string(current_step) + '\n';
		return result;
	}

	CPU::~CPU()
	{
		delete[] ram;
		delete[] program;
	}

	void CPU::reset_regs()
	{
		prog_counter = 0;

		for (int i = 0; i < CPU_REG_COUNT; i++) {
			reg_mem[i] = 0;
		}
	}

	void CPU::reset_flags()
	{
		halt = false;
		zero = false;
		sign = false;
	}

	void CPU::compare(int x, int y)
	{
		int res = x - y;
		zero = res == 0;
		sign = res < 0;
	}

	short CPU::read_prog_mem(int ptr)
	{
		ptr_check(ptr, prog_mem_capacity, "Bad program memory pointer.");

		return program[ptr];
	}

	short CPU::read_operand()
	{
		prog_counter += 1;
		return read_prog_mem(prog_counter);
	}

	short CPU::read_ram(int ptr)
	{
		ptr_check(ptr, ram_capacity, "Reading RAM failure: bad RAM pointer.");

		return ram[ptr];
	}

	void CPU::write_ram(int ptr, short data)
	{
		ptr_check(ptr, prog_mem_capacity, "Writing RAM failure: bad RAM pointer.");
	}

	void CPU::ptr_check(int ptr, int capacity, std::string commentary = "")
	{
		if ((ptr > capacity) || (ptr < 0)) {
			//todo: write nice cool looking exception classes for any type of exceptions
			const char* response = ("Pointer error. Commentary: '" + commentary + "'").c_str();
			throw std::exception(response);
		}
	}



}
