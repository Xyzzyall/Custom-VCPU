#include "CPU.h"
#include <exception>
#include <string>

#define COPY_REG0_TO_REGX(x) case CMD_COPY_REG0_TO_REGX + x: reg_mem[x] = reg_mem[0]; break;
#define COPY_REGX_TO_REG0(x) case CMD_COPY_REGX_TO_REG0 + x: reg_mem[0] = reg_mem[x]; break;
#define CMD_CMP_REGX(x) case CMD_CMP_REGX + x: compare(reg_mem[0], reg_mem[x]); break;
#define CMD_INC_REGX(x) case CMD_INC_REGX + x: reg_mem[x]++; break;

CPU::CPU(int ram_capacity, int prog_mem_capacity)
{
	//initializing 
	this->ram = new short[ram_capacity];
	this->ram_capacity = ram_capacity;

	this->prog_mem_capacity = prog_mem_capacity;
	this->program = new short[prog_mem_capacity];

	reset_regs();
	reset_flags();

	this->step = 0;
}

void CPU::step()
{
	if (halt) {
		return;
	}

	//reading current cmd
	short cmd = read_prog_mem(prog_counter);

	switch (cmd)
	{
	case CMD_CHILL:
		break;
	case CMD_HALT:
		halt = true;
		break;
	case CMD_READ_TO_REG0:
		short op = read_operand();
		reg_mem[0] = read_ram(op);
		break;
	case CMD_SET_INDEX:
		short op = read_operand();
		reg_mem[7] = op;
		break;

	//Macros declarations down there, maybe doing it outside switch was better solution.
	//COPY_REG0_TO_REGX cases generated by macros
	COPY_REG0_TO_REGX(1)
	COPY_REG0_TO_REGX(2)
	COPY_REG0_TO_REGX(3)
	COPY_REG0_TO_REGX(4)
	COPY_REG0_TO_REGX(5)
	COPY_REG0_TO_REGX(6)
	COPY_REG0_TO_REGX(7)

	//COPY_REGX_TO_REG0 cases generated by macros
	COPY_REGX_TO_REG0(1)
	COPY_REGX_TO_REG0(2)
	COPY_REGX_TO_REG0(3)
	COPY_REGX_TO_REG0(4)
	COPY_REGX_TO_REG0(5)
	COPY_REGX_TO_REG0(6)
	COPY_REGX_TO_REG0(7)

	//CMD_CMP_REGX cases generated by macros
	CMD_CMP_REGX(1)
	CMD_CMP_REGX(2)
	CMD_CMP_REGX(3)
	CMD_CMP_REGX(4)
	CMD_CMP_REGX(5)
	CMD_CMP_REGX(6)
	CMD_CMP_REGX(7)

	//CMD_INC_RECX cases generated by macros
	CMD_INC_REGX(0)
	CMD_INC_REGX(1)
	CMD_INC_REGX(2)
	CMD_INC_REGX(3)
	CMD_INC_REGX(4)
	CMD_INC_REGX(5)
	CMD_INC_REGX(6)
	CMD_INC_REGX(7)
	default:
		throw new std::exception("Cannot decode next command.");
		break;
	}

	prog_counter++;
	current_step++;
}

void CPU::steps(int steps)
{
	for (int i = 0; i < steps; i++)
	{
		step();
		if (halt) {
			break;
		}
	}
}

void CPU::goto_step(int step)
{
	//WIP feature!!!!
}

void CPU::reset_CPU()
{
	erase_memory();

	reset_regs();
}

void CPU::load_memory(std::string prog_bin, std::string ram_bin)
{
	erase_memory();
	load_program(prog_bin);
	load_ram(ram_bin);
}

void CPU::load_program(std::string bin_file)
{
}

void CPU::load_ram(std::string bin_file)
{
}

void CPU::erase_memory()
{
	if ((ram_capacity > 0) && (prog_mem_capacity > 0)) {
		for (int i = 0; i < ram_capacity; i++)
		{
			ram[i] = 0;
		}

		for (int i = 0; i < prog_mem_capacity; i++)
		{
			program[i] = 0;
		}
	}
	else {
		//todo: write nice cool looking exception classes for any type of exceptions
		throw new std::exception("Somehow memory size vars is corrupted.");
	}
}

std::string CPU::tell_me_about_yourself()
{
	std::string result = "";
	result += "registers:\n" ;
	result += "PC = " + std::to_string(prog_counter) + '\n';
	for (int i = 0; i < CPU_REG_COUNT; i++) {
		result += "reg" + std::to_string(i) + " = " + std::to_string(reg_mem[i]) + '\n';
	}
	return result;
}

CPU::~CPU()
{
	delete[] ram;
	delete[] program;
}

void CPU::reset_regs()
{
	prog_counter = 0;

	for (int i = 0; i < CPU_REG_COUNT; i++) {
		reg_mem[i] = 0;
	}
}

void CPU::reset_flags()
{
	halt = false;
	zero = false;
	sign = false;
}

void CPU::compare(int x, int y)
{
	int res = x - y;
	zero = res == 0;
	sign = res < 0;
}

short CPU::read_prog_mem(int ptr)
{
	ptr_check(ptr, prog_mem_capacity, "Bad program memory pointer.");

	return program[ptr];
}

short CPU::read_operand()
{
	prog_counter += 1;
	return read_prog_mem(prog_counter);
}

short CPU::read_ram(int ptr)
{
	ptr_check(ptr, ram_capacity, "Reading RAM failure: bad RAM pointer.");

	return 0;
}

void CPU::write_ram(int ptr, short data)
{
	ptr_check(ptr, prog_mem_capacity, "Writing RAM failure: bad RAM pointer.");
}

void CPU::ptr_check(int ptr, int capacity, std::string commentary="")
{
	if ((ptr > capacity) || (ptr < 0)) {
		throw new std::exception(("Pointer error. Commentary: '" + commentary + "'").data);
	}
}


